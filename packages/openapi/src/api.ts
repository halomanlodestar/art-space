/* tslint:disable */
/* eslint-disable */
/**
 * Art Space
 * This api is for the Art Space project
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CommentEntity
 */
export interface CommentEntity {
    /**
     * 
     * @type {string}
     * @memberof CommentEntity
     */
    'parentId': string | null;
    /**
     * 
     * @type {string}
     * @memberof CommentEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CommentEntity
     */
    'postId': string;
    /**
     * 
     * @type {string}
     * @memberof CommentEntity
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof CommentEntity
     */
    'authorId': string;
    /**
     * 
     * @type {string}
     * @memberof CommentEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CommentEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface CommunityEntity
 */
export interface CommunityEntity {
    /**
     * 
     * @type {string}
     * @memberof CommunityEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CommunityEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CommunityEntity
     */
    'createdById': string;
    /**
     * 
     * @type {string}
     * @memberof CommunityEntity
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof CommunityEntity
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CommunityEntity
     */
    'image': string | null;
    /**
     * 
     * @type {string}
     * @memberof CommunityEntity
     */
    'banner': string;
    /**
     * 
     * @type {string}
     * @memberof CommunityEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CommunityEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface CreateCommunityDto
 */
export interface CreateCommunityDto {
    /**
     * 
     * @type {string}
     * @memberof CreateCommunityDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCommunityDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface CreatePostDto
 */
export interface CreatePostDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePostDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePostDto
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface LikeEntity
 */
export interface LikeEntity {
    /**
     * 
     * @type {string}
     * @memberof LikeEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LikeEntity
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof LikeEntity
     */
    'postId': string;
    /**
     * 
     * @type {string}
     * @memberof LikeEntity
     */
    'commentId': string | null;
    /**
     * 
     * @type {string}
     * @memberof LikeEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LikeEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface PostEntity
 */
export interface PostEntity {
    /**
     * 
     * @type {string}
     * @memberof PostEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PostEntity
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PostEntity
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof PostEntity
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof PostEntity
     */
    'authorId': string;
    /**
     * 
     * @type {string}
     * @memberof PostEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PostEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PostEntity
     */
    'communityId': string;
}
/**
 * 
 * @export
 * @interface RefreshResponseDto
 */
export interface RefreshResponseDto {
    /**
     * 
     * @type {string}
     * @memberof RefreshResponseDto
     */
    'accessToken': string;
}
/**
 * 
 * @export
 * @interface SafeUserDto
 */
export interface SafeUserDto {
    /**
     * 
     * @type {string}
     * @memberof SafeUserDto
     */
    'portfolioId': string | null;
    /**
     * 
     * @type {string}
     * @memberof SafeUserDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SafeUserDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SafeUserDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof SafeUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SafeUserDto
     */
    'image': string | null;
    /**
     * 
     * @type {object}
     * @memberof SafeUserDto
     */
    'provider': object;
    /**
     * 
     * @type {object}
     * @memberof SafeUserDto
     */
    'role': object;
    /**
     * 
     * @type {string}
     * @memberof SafeUserDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SafeUserDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface SignInDto
 */
export interface SignInDto {
    /**
     * 
     * @type {string}
     * @memberof SignInDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignInDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface SignInResponseDto
 */
export interface SignInResponseDto {
    /**
     * 
     * @type {string}
     * @memberof SignInResponseDto
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof SignInResponseDto
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface SignUpDto
 */
export interface SignUpDto {
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateCommunityDto
 */
export interface UpdateCommunityDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateCommunityDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCommunityDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdatePostsDto
 */
export interface UpdatePostsDto {
    /**
     * 
     * @type {string}
     * @memberof UpdatePostsDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePostsDto
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface UserEntity
 */
export interface UserEntity {
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'image': string | null;
    /**
     * 
     * @type {object}
     * @memberof UserEntity
     */
    'provider': object;
    /**
     * 
     * @type {object}
     * @memberof UserEntity
     */
    'role': object;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'communityId': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'updatedAt': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getCurrentUser', 'authorization', authorization)
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleCallback: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/google/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken: async (authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('refreshAccessToken', 'authorization', authorization)
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signIn: async (signInDto: SignInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInDto' is not null or undefined
            assertParamExists('signIn', 'signInDto', signInDto)
            const localVarPath = `/auth/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInWithGoogle: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/signin/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp: async (signUpDto: SignUpDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpDto' is not null or undefined
            assertParamExists('signUp', 'signUpDto', signUpDto)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async googleCallback(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.googleCallback(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.googleCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshAccessToken(authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAccessToken(authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshAccessToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signIn(signInDto: SignInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signIn(signInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.signIn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signInWithGoogle(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signInWithGoogle(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.signInWithGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUp(signUpDto: SignUpDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signUp(signUpDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.signUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {string} authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(authorization: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getCurrentUser(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleCallback(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.googleCallback(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken(authorization: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.refreshAccessToken(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signIn(signInDto: SignInDto, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.signIn(signInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInWithGoogle(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.signInWithGoogle(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignUpDto} signUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp(signUpDto: SignUpDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.signUp(signUpDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {string} authorization Bearer token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getCurrentUser(authorization: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getCurrentUser(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public googleCallback(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).googleCallback(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} authorization Bearer token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshAccessToken(authorization: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshAccessToken(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignInDto} signInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public signIn(signInDto: SignInDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).signIn(signInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public signInWithGoogle(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).signInWithGoogle(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignUpDto} signUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public signUp(signUpDto: SignUpDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).signUp(signUpDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CommunitiesApi - axios parameter creator
 * @export
 */
export const CommunitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} authorization Bearer token
         * @param {CreateCommunityDto} createCommunityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCommunity: async (authorization: string, createCommunityDto: CreateCommunityDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createCommunity', 'authorization', authorization)
            // verify required parameter 'createCommunityDto' is not null or undefined
            assertParamExists('createCommunity', 'createCommunityDto', createCommunityDto)
            const localVarPath = `/communities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCommunityDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCommunity: async (id: string, authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCommunity', 'id', id)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('deleteCommunity', 'authorization', authorization)
            const localVarPath = `/communities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllCommunities: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/communities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCommunityById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findCommunityById', 'id', id)
            const localVarPath = `/communities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostsByCommunity: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('getPostsByCommunity', 'slug', slug)
            const localVarPath = `/communities/{slug}/posts`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCommunities: async (search: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            assertParamExists('searchCommunities', 'search', search)
            const localVarPath = `/communities/search/{search}`
                .replace(`{${"search"}}`, encodeURIComponent(String(search)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} authorization Bearer token
         * @param {UpdateCommunityDto} updateCommunityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCommunity: async (id: string, authorization: string, updateCommunityDto: UpdateCommunityDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCommunity', 'id', id)
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateCommunity', 'authorization', authorization)
            // verify required parameter 'updateCommunityDto' is not null or undefined
            assertParamExists('updateCommunity', 'updateCommunityDto', updateCommunityDto)
            const localVarPath = `/communities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCommunityDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommunitiesApi - functional programming interface
 * @export
 */
export const CommunitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommunitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} authorization Bearer token
         * @param {CreateCommunityDto} createCommunityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCommunity(authorization: string, createCommunityDto: CreateCommunityDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCommunity(authorization, createCommunityDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunitiesApi.createCommunity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCommunity(id: string, authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCommunity(id, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunitiesApi.deleteCommunity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllCommunities(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllCommunities(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunitiesApi.findAllCommunities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findCommunityById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findCommunityById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunitiesApi.findCommunityById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostsByCommunity(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostsByCommunity(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunitiesApi.getPostsByCommunity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCommunities(search: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCommunities(search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunitiesApi.searchCommunities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} authorization Bearer token
         * @param {UpdateCommunityDto} updateCommunityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCommunity(id: string, authorization: string, updateCommunityDto: UpdateCommunityDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCommunity(id, authorization, updateCommunityDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommunitiesApi.updateCommunity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommunitiesApi - factory interface
 * @export
 */
export const CommunitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommunitiesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} authorization Bearer token
         * @param {CreateCommunityDto} createCommunityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCommunity(authorization: string, createCommunityDto: CreateCommunityDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createCommunity(authorization, createCommunityDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} authorization Bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCommunity(id: string, authorization: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCommunity(id, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllCommunities(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.findAllCommunities(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCommunityById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.findCommunityById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostsByCommunity(slug: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getPostsByCommunity(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCommunities(search: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.searchCommunities(search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} authorization Bearer token
         * @param {UpdateCommunityDto} updateCommunityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCommunity(id: string, authorization: string, updateCommunityDto: UpdateCommunityDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateCommunity(id, authorization, updateCommunityDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommunitiesApi - object-oriented interface
 * @export
 * @class CommunitiesApi
 * @extends {BaseAPI}
 */
export class CommunitiesApi extends BaseAPI {
    /**
     * 
     * @param {string} authorization Bearer token
     * @param {CreateCommunityDto} createCommunityDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunitiesApi
     */
    public createCommunity(authorization: string, createCommunityDto: CreateCommunityDto, options?: RawAxiosRequestConfig) {
        return CommunitiesApiFp(this.configuration).createCommunity(authorization, createCommunityDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} authorization Bearer token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunitiesApi
     */
    public deleteCommunity(id: string, authorization: string, options?: RawAxiosRequestConfig) {
        return CommunitiesApiFp(this.configuration).deleteCommunity(id, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunitiesApi
     */
    public findAllCommunities(options?: RawAxiosRequestConfig) {
        return CommunitiesApiFp(this.configuration).findAllCommunities(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunitiesApi
     */
    public findCommunityById(id: string, options?: RawAxiosRequestConfig) {
        return CommunitiesApiFp(this.configuration).findCommunityById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunitiesApi
     */
    public getPostsByCommunity(slug: string, options?: RawAxiosRequestConfig) {
        return CommunitiesApiFp(this.configuration).getPostsByCommunity(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} search 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunitiesApi
     */
    public searchCommunities(search: string, options?: RawAxiosRequestConfig) {
        return CommunitiesApiFp(this.configuration).searchCommunities(search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} authorization Bearer token
     * @param {UpdateCommunityDto} updateCommunityDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunitiesApi
     */
    public updateCommunity(id: string, authorization: string, updateCommunityDto: UpdateCommunityDto, options?: RawAxiosRequestConfig) {
        return CommunitiesApiFp(this.configuration).updateCommunity(id, authorization, updateCommunityDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LikesApi - axios parameter creator
 * @export
 */
export const LikesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikePost: async (postId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postId' is not null or undefined
            assertParamExists('unlikePost', 'postId', postId)
            const localVarPath = `/likes`
                .replace(`{${"postId"}}`, encodeURIComponent(String(postId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LikesApi - functional programming interface
 * @export
 */
export const LikesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LikesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlikePost(postId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlikePost(postId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LikesApi.unlikePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LikesApi - factory interface
 * @export
 */
export const LikesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LikesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikePost(postId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unlikePost(postId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LikesApi - object-oriented interface
 * @export
 * @class LikesApi
 * @extends {BaseAPI}
 */
export class LikesApi extends BaseAPI {
    /**
     * 
     * @param {string} postId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikesApi
     */
    public unlikePost(postId: string, options?: RawAxiosRequestConfig) {
        return LikesApiFp(this.configuration).unlikePost(postId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PostsApi - axios parameter creator
 * @export
 */
export const PostsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createComment', 'id', id)
            const localVarPath = `/posts/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreatePostDto} createPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewPost: async (createPostDto: CreatePostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPostDto' is not null or undefined
            assertParamExists('createNewPost', 'createPostDto', createPostDto)
            const localVarPath = `/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePost: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePost', 'id', id)
            const localVarPath = `/posts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} skip 
         * @param {number} take 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchLatestPosts: async (skip: number, take: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'skip' is not null or undefined
            assertParamExists('fetchLatestPosts', 'skip', skip)
            // verify required parameter 'take' is not null or undefined
            assertParamExists('fetchLatestPosts', 'take', take)
            const localVarPath = `/posts/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPosts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostBySlug: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('getPostBySlug', 'slug', slug)
            const localVarPath = `/posts/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostComments: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPostComments', 'id', id)
            const localVarPath = `/posts/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLikedPosts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/posts/liked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdatePostsDto} updatePostsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePost: async (id: string, updatePostsDto: UpdatePostsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePost', 'id', id)
            // verify required parameter 'updatePostsDto' is not null or undefined
            assertParamExists('updatePost', 'updatePostsDto', updatePostsDto)
            const localVarPath = `/posts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePostsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostsApi - functional programming interface
 * @export
 */
export const PostsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PostsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createComment(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createComment(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.createComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreatePostDto} createPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewPost(createPostDto: CreatePostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewPost(createPostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.createNewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePost(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePost(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.deletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} skip 
         * @param {number} take 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchLatestPosts(skip: number, take: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchLatestPosts(skip, take, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.fetchLatestPosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPosts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPosts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.getAllPosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostBySlug(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostBySlug(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.getPostBySlug']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostComments(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostComments(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.getPostComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserLikedPosts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserLikedPosts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.getUserLikedPosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdatePostsDto} updatePostsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePost(id: string, updatePostsDto: UpdatePostsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePost(id, updatePostsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.updatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PostsApi - factory interface
 * @export
 */
export const PostsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PostsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createComment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreatePostDto} createPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewPost(createPostDto: CreatePostDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createNewPost(createPostDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePost(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} skip 
         * @param {number} take 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchLatestPosts(skip: number, take: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.fetchLatestPosts(skip, take, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPosts(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getAllPosts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostBySlug(slug: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getPostBySlug(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostComments(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getPostComments(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLikedPosts(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getUserLikedPosts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdatePostsDto} updatePostsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePost(id: string, updatePostsDto: UpdatePostsDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updatePost(id, updatePostsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostsApi - object-oriented interface
 * @export
 * @class PostsApi
 * @extends {BaseAPI}
 */
export class PostsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public createComment(id: string, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).createComment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreatePostDto} createPostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public createNewPost(createPostDto: CreatePostDto, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).createNewPost(createPostDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public deletePost(id: string, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).deletePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} skip 
     * @param {number} take 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public fetchLatestPosts(skip: number, take: number, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).fetchLatestPosts(skip, take, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public getAllPosts(options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).getAllPosts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public getPostBySlug(slug: string, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).getPostBySlug(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public getPostComments(id: string, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).getPostComments(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public getUserLikedPosts(options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).getUserLikedPosts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdatePostsDto} updatePostsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public updatePost(id: string, updatePostsDto: UpdatePostsDto, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).updatePost(id, updatePostsDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByUsername: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('findByUsername', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findByUsername(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findByUsername(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findByUsername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByUsername(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.findByUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateUser(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findByUsername(username: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).findByUsername(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(options).then((request) => request(this.axios, this.basePath));
    }
}



